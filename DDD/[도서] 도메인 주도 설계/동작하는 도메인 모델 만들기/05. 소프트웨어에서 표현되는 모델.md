# 05. 소프트웨어에서 표현되는 모델

### 엔티티 (Entity)
* 엔티티를 정하는 기준
  * 엔티티는 꼭 현실세계에서 나타내는 사람, 사물만이 아님
    * 뱅킹 애플리케이션에서 일어나는 거래
      * 같은 날 같은 계좌에 같은 금액을 예금하더라도 두 **예금**은 별개의 식별성(identity)을 가지고 있으므로 **엔티티에 해당**
      * 각 예금에서 일어난 **금액**은 같은 금액을 가지고 있고 이는 구별될 필요가 없으므로 **엔티티에 해당하지 않음**
  * 식별성은 세상에 존재하는 것이 아님
  * 현실세계에선 같은 사물이라도 도메인 모델에서는 엔티티로 표현되거나 표현되지 않을 수 있음
  * 경기장 좌석 예약
    * 관객
      * 엔티티
    * 좌석
      * 지정석인 경우 - 엔티티
      * 아무데나 앉을 수 있는 경우 - 엔티티가 아님 (좌석의 개수만 중요)
   

* 식별 연산의 설계
  * 객체지향 언어의 객체 메모리 주소로 한다면? 
    * 대부분의 객체 영속화 기술은 DB에서 객체를 가져올 때마다 새로운 인스턴스를 생성하므로 초기 식별성을 잃어버림
    * 갱신 내역이 분산된 데이터베이스를 거쳐 전달되는 경우 여러 버전의 동일한 객체가 시스템에 존재하게 되면 문제는 더 심각해짐
  * 식별성을 정의하려면 도메인을 이해해야 한다
    * 예: 신문의 제목, 도시, 발행일
  * 자동으로 ID가 생성되는 경우도 가능
    * auto increment, uuid 등
    * 사용자에게 보여줘야 할까?
      * 경우에 따라 다르다
        * 사용자 이름에 따라 연락처를 찾아주는 연락처 관리 애플리케이션의 경우 보여줄 필요가 없다
        * 화물배송 서비스의 경우 조회번호가 필요할 수도 있다
  * ID의 유일성이 시스템의 범위를 넘어 적용되어야 할 때도 있다
    * 두 병원 간에 의료 기록을 교환하는 경우

### 값 객체 (Value Object)
* 엔티티의 식별성을 관리하는 일은 매우 중요
  * 그 밖의 객체에 식별성을 추가한다면?
    * 시스템의 성능이 저하
    * 분석 작업이 별도로 필요
    * 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워질 수 있으
* 소프트웨어 설계는 복잡성과의 끊임없는 전투
  * 특별하게 다뤄야 할 부분과 그렇지 않은 부분을 구분
* 값 객체
  * 개념적 식별성을 갖지 않음
  * 도메인의 서술적 측면을 나타냄
* "주소"는 값 객체일까?
  * **우편 주문 회사**
    * 두 사람이 같은 장소로 물건을 주문했을 때의 주소는 **값 객체**
  * **우편 서비스**
    * 배송 경로 조직화를 위해 `도시` > `우편 구역` > `블록` > `주소`로 끝나는 계층 구조로 되어있는 상태
    * 배달 구역을 재할당한다면 모든 주소는 부모 계층의 주소를 따라 바뀔 것이며 이는 **엔티티**
  * **전기 설비 회사**
    * 룸메이트가 각자 전기 점검을 요청한 상황
      * 점검 목적지를 파악할 때는 **엔티티** 또는 주소 속성이 **값 객체**로 포함된 어떤 엔티티로 확인할 수도 있다
