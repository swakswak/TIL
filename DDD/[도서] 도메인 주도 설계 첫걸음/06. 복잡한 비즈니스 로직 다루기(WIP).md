# 06. 복잡한 비즈니스 로직 다루기 (WIP)

* DDD의 전술 패턴
  * 애그리게이트
  * 밸류 오브젝트
  * 도메인 이벤트
  * 도메인 서비스

* 위의 패턴은 비즈니스 로직을 최우선으로 둔다는 것이 공통 관심사

### 복잡성

* 도메인 비즈니스 로직은 이미 본질적으로 복잡
    * 조금이라도 우발적 복잡성을 추가하면 안됨
* 모델에 피해야 하는 관심사
    * 데이터베이스/외부 시스템 구성요소의 호출 구현과 같이 인프라 또는 기술적인 관심사
* 위의 제약을 잘 따르면 모델 객체는 플레인 올드 오브젝트(POJO, POCO, POPO)가 됨
* 플레인 올드 오브젝트가 되면 인프라 구성 요소 또는 프레임워크에 의지하지 않고 직접 협업하지 않으면서 비즈니스 로직을 구현하는 객체가 됨

### 유비쿼터스 언어

* 도메인 모델의 객체가 기술적인 관심을 갖지 않고 비즈니스 로직에 집종하게 되면 바운디드 컨텍스트에서 사용하는 유비쿼터스 언어의 용어를 따르기 쉬워짐
* 도메인 전문가의 멘탈 모델을 따르자

### 밸류 오브젝트

* 색(color)과 같이 복합적인 값에 의해 식별되는 객체
  ```csharp
  class Color
  {
    public Color(int red, int green, int blue) 
    {
      Red = red;
      Green = green;
      Blue = blue;
    }
  
    public Red { get; }
    public Green { get; }
    public Blue { get; }
  }
  ```
* RGB 세 값이 복합적으로 색을 정의
* 빌드 중 하나의 값이 바뀌면 새로운 색이 탄생
* 같은 값을 갖는 색은 존재하지 않음
* 같은 색의 두 인스턴스는 반드시 같은 값을 가짐
* 색을 식별할 또다른 필드가 필요 없음
    * id를 갖는다면? -> id 만으로 값은 값인지 알 수 없다.

**유비쿼터스 언어**

* 비즈니스 도메인 개념의 표현을 원시 데이터 타입으로 하지 말자
* 키, 전화번호, 색과 같은 개념을 밸류 오브젝트로 표현할 때 구현된 시스템의 타입이 더욱 풍부해지고 사용하기에 직관적
* height: `int` 타입 보다는 `Height` 타입으로
  ```csharp
  var heightMetric = Hegith.Metric(180);
  var heightImperial = Height.Imperial(5, 3);
    
  var string1 = heightMetric.ToString();              // "180cm"
  var string2 = heightImperial.ToString();            // "5 feet 3 inches"
  var string3 = hegithMetric.ToImperial().ToString(); // "5 feet 11 inches" 
    
  var firstIsHigher = heightMetric > heightImperial;   // true
  ```
* phoneNumber: 밸류 오브젝트로 할 경우 값 파싱, 유효성 검사, 소속된 국가 또는 무선 전화번호와 같은 다양한 전화번호 속성 추출 가능
  ```csharp
  var phone = PhoneNumber.Parse("+359877123503");
  var country = phone.Country;                        // "BG"
  var phoneType = phoen.PhoneType;                    // "MOBILE"
  var isValid = PhoneNumber.IsValid("+972120266680"); // false
  ```
* color: 밸류 오브젝트의 데이터를 조작, 새로운 밸류 오브젝트 인스턴스 생성
  ```csharp
  var red = Color.FromRGB(255, 0, 0);
  var green = Color.Green;
  var yellow = red.MixWith(green);
  var yellowString = yellow.ToString();               // "#FFFF00"
  ```
    * VO는 불변!
        * 밸류 오브젝트에 있는 필드가 하나라도 바뀌면 인스턴스의 상태를 변경하는 것이 아닌 바뀐 값을 갖는 새 인스턴스가 생성되어야 함
        * 불변이기 때문에 내포된 동작은 부작용과 동시성 문제가 없음
    
### 엔티티
* 엔티티는 밸류 오브젝트와 정반대
* 다른 엔티티와 구별하기 위한 명시적인 식별 필드(예: id, code, uuid 등)가 필요하다.
  * 식별 필드는 엔티티의 생애 주기 내내 불변이어야 함
* 엔티티는 불변이 아님
* 밸류 오브젝트는 엔티티의 속성을 설명
  * Person 타입의 personId, name
* 모든 비즈니스 도메인의 필수 구성 요소    

### 애그리게이트 ([Aggregate](https://martinfowler.com/bliki/DDD_Aggregate.html))
* 데이터의 일관성은 애그리게이트의 비즈니스 로직을 통해서만 애그리게이트의 상태를 변경하게 해야 함
* 애그리게이트의 퍼블릭 인터페이스로 상태 변경 메서드 노출
  * 유효성 검사
  * 관련된 모든 비즈니스 규칙을 한 곳에서 관리
  * 애플리케이션 계층(서비스 계층)의 조율 동작을 조금 더 간단하게 만들 수 있음

어떻게 구현할 지는 선호도의 문제
```csharp
// 방법 1
public class Ticket
{
  ...
  
  public void AddMessage(UserId from, string body) {...}
}
```
```csharp
// 방법 2
public class Ticket
{
  ...
  
  public void Execute(AddMessage cmd) {...}
}
```