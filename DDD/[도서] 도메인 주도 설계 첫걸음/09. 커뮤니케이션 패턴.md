# 09. 커뮤니케이션 패턴 (WIP)
* 바운디드 컨텍스트 간 커뮤니케이션

* 내용을 다루기 앞서 [바운디드 컨텍스트 연동](./04.%20바운디드%20컨텍스트%20연동%20(구분과%20협력).md) 내용을 참고
## 모델 변환
* 서로 다른 바운디드 컨텍스트의 컨텍스트의 커뮤니케이션 
  * 사용자-제공자 패턴에서 사용자가 제공자의 바운디드 컨텍스트 모델을 따를 수 없는 상황이라면?
    * 필요에 따라 한쪽 또는 양쪽이 변환
  * Stateless translation
    * 수신(OHS) 또는 발신(ACL) 요청이 발행될 때 즉석에서 발생
  * Stateful translation
    * 상태 보존을 위해 데이터베이스 사용
  
### 무상태 변환 (Stateless translation)
* 프락시 패턴을 구현해 수신, 발신 요청을 삽입
* `요청` - (ModelA) -> `프락시` - (ModelB) -> `목표`
   

* 동기식
  ```
  바운디드   ----요청---->   프락시    --변환된요청-->    바운디드
  컨텍스트1  <--변환된응답--           <----응답----    컨텍스트2
  ```
  * API 게이트웨이에 변환 로직을 두는 경우도 있음

  * 오픈 호스트 서비스 패턴 (OHS)
    * 사용자에게 맞추는 패턴 
    * API 게이트웨이에서 바운디드 컨텍스트 API의 버저닝을 통해 사용자에게 맞춰줄 수 있음

  * 충돌 방지 계층 패턴 (ACL)
    * 제공자에게 맞추는 패턴
    * API 게이트웨이가 충돌 방지 계층이 됨
      * API 게이트웨이는 다른 사용자가 편리하게 사용할 수 있게 모델을 변환
      * 사용자는 API 게이트웨이를 통해 커뮤니케이션

* 비동기
  * `제공자` -> `MQ`-> `메시지 변환기(OHS)`-> `MQ` -> `사용자`

### 상태 변환 (Stateful translation)
* `요청1` `요청2` `요청3` -> `애그리게이터` -> `일괄처리(요청1, 요청2, 요청3)`
  * 원천 데이터 집계
  * 여러 요청에서 들어오는 데이터를 단일 모델로 통합
  
* Kafka, AWS Kinesis
* Apache NiFi, AWS Glue, Spark 

* BFF (Backend For Frontend) 패턴 또한 상태 변환

### 애그리게이트 연동
만약 특정 애그리게이트의 상태가 deactivated로 되었고 이후 이벤트를 발행한다면?
* 애그리게이트의 상태가 커밋된 이후에 이벤트를 발행해야 함
* 만약 이벤트 버스가 다운됐다면?
  * 아웃박스 패턴을 활용하면 된다
    

* 아웃박스 패턴
  * 데이터베이스에 현재 상태와 새 이벤트를 함께 저장
  * 메시지 릴레이는 마지막으로 가져간 이벤트 이후의 이벤트만 가져가서 이벤트 발행
  * ```json
    {
      "id": "e0743a30-53a3-11ed-bdc3-0242ac120002",
      "state": {
        // 애그리게이트 현재 상태
      },
      "outbox": [
        {
          "id": "e0743a30-53a3-11ed-bdc3-0242ac120002",
          "published": false,
          // 이벤트 내용
        },
        ...
      ]
    }
    ```
  * 두 가지 방법으로 가져갈 수 있다.
    * 풀: 발행자 폴링
      * DB에 주기적으로 질의
      * 부하를 최소화하려면 적절한 인덱스 필요
    * 푸시: 트랜잭션 로그 추적
      * RDB에서 트랜잭션 로그를 추적해 업데이트/삽입 시 알림을 받을 수 있음
      * DynamoDB Streams를 이용해 커민된 변경사항을 스트림에 노출
   

* 사가 (Saga)
  * 애그리게이트 설계 원칙 중 하나는 트랜잭션을 애그리게이트의 단일 인스턴스로 제한하는 것
  * 만약 여러 애그리게이트에 걸쳐있는 비즈니스 프로세스라면?
